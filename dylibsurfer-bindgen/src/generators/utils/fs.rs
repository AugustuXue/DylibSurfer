//! 文件系统工具，用于处理生成的代码文件输出。

use std::fs;
use std::io;
use std::path::{Path, PathBuf};

/// 创建库输出目录
///
/// 根据基础目录和库名，创建输出目录结构。
///
/// # 参数
/// - `base_dir`: 基础输出目录
/// - `lib_name`: 库名称
///
/// # 返回值
/// - `Ok(PathBuf)`: 成功时返回创建的目录路径
/// - `Err(io::Error)`: 如果创建目录失败，返回 IO 错误
pub fn create_lib_output_dir(base_dir: &Path, lib_name: &str) -> io::Result<PathBuf> {
    let lib_dir = base_dir.join(lib_name);
    fs::create_dir_all(&lib_dir)?;
    Ok(lib_dir)
}

/// 写入生成的代码到文件
///
/// 将生成的代码字符串写入指定目录下的文件。
///
/// # 参数
/// - `base_dir`: 基础输出目录
/// - `lib_name`: 库名称
/// - `file_name`: 文件名
/// - `code`: 代码内容
///
/// # 返回值
/// - `Ok(())`: 成功时返回空元组
/// - `Err(io::Error)`: 如果写入文件失败，返回 IO 错误
pub fn write_generated_code(base_dir: &Path, lib_name: &str, file_name: &str, code: &str) -> io::Result<()> {
    let lib_dir = create_lib_output_dir(base_dir, lib_name)?;
    let file_path = lib_dir.join(file_name);
    fs::write(file_path, code)
}

/// 为给定的库名生成 Cargo.toml 文件
///
/// 在指定目录下创建一个包含基本依赖的 Cargo.toml 文件。
///
/// # 参数
/// - `output_dir`: 输出目录
/// - `lib_name`: 库名称
///
/// # 返回值
/// - `Ok(())`: 成功时返回空元组
/// - `Err(io::Error)`: 如果写入文件失败，返回 IO 错误
pub fn generate_cargo_toml(output_dir: &Path, lib_name: &str) -> io::Result<()> {
    let lib_dir = create_lib_output_dir(output_dir, lib_name)?;
    let cargo_toml = lib_dir.join("Cargo.toml");
    
    let content = format!(
        r#"[package]
name = "{0}-ffi"
version = "0.1.0"
edition = "2021"
description = "FFI bindings for {0}"
license = "MIT"

[dependencies]
libc = "0.2"

[lib]
name = "{0}_ffi"
path = "src/lib.rs"
"#,
        lib_name
    );
    
    fs::write(cargo_toml, content)
}

/// 生成 lib.rs 文件，将所有生成的模块组合起来
///
/// 在指定目录下创建一个 lib.rs 文件，导出所有生成的模块。
///
/// # 参数
/// - `output_dir`: 输出目录
/// - `lib_name`: 库名称
/// - `modules`: 模块名称列表
///
/// # 返回值
/// - `Ok(())`: 成功时返回空元组
/// - `Err(io::Error)`: 如果写入文件失败，返回 IO 错误
pub fn generate_lib_rs(output_dir: &Path, lib_name: &str, modules: &[&str]) -> io::Result<()> {
    let lib_dir = create_lib_output_dir(output_dir, lib_name)?;
    let src_dir = lib_dir.join("src");
    fs::create_dir_all(&src_dir)?;
    
    let lib_rs = src_dir.join("lib.rs");
    
    let mut content = format!(
        r#"//! FFI bindings for {0}
//!
//! This module provides Rust FFI bindings for the {0} C library.
//! Generated by DylibSurfer.

"#,
        lib_name
    );
    
    // 添加模块声明
    for module in modules {
        content.push_str(&format!("pub mod {};\n", module));
    }
    
    // 添加类型和函数重导出
    content.push_str("\n// Re-export commonly used types and functions\n");
    
    fs::write(lib_rs, content)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::tempdir;
    
    #[test]
    fn test_create_lib_output_dir() {
        let temp_dir = tempdir().unwrap();
        let base_path = temp_dir.path();
        
        let result = create_lib_output_dir(base_path, "test_lib");
        assert!(result.is_ok());
        
        let lib_dir = base_path.join("test_lib");
        assert!(lib_dir.exists());
        assert!(lib_dir.is_dir());
    }
    
    #[test]
    fn test_write_generated_code() {
        let temp_dir = tempdir().unwrap();
        let base_path = temp_dir.path();
        
        let code = "// Test code\nfn test() {}\n";
        let result = write_generated_code(base_path, "test_lib", "test.rs", code);
        assert!(result.is_ok());
        
        let file_path = base_path.join("test_lib").join("test.rs");
        assert!(file_path.exists());
        
        let content = fs::read_to_string(file_path).unwrap();
        assert_eq!(content, code);
    }
}
